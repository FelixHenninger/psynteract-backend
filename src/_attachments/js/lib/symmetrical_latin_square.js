// Generated by CoffeeScript 1.10.0
var _, decode_suggestion, generate_suggestions, inverse_triangular, linear_coordinates, suggestions_to_matrix, symmetrical_latin_square, triangular, triangular_coordinates, x;

triangular = function(i) {
  return i * (i + 1) / 2;
};

inverse_triangular = function(i) {
  return Math.sqrt(8 * i + 1) / 2 - 0.5;
};

triangular_coordinates = function(i) {
  var column, row;
  row = Math.ceil(inverse_triangular(i));
  column = i - triangular(row - 1) - 1;
  return [row, column];
};

linear_coordinates = function(row, column, n, skip_diagonal) {
  var diagonals_seen;
  if (skip_diagonal == null) {
    skip_diagonal = true;
  }
  if (skip_diagonal) {
    diagonals_seen = row;
    if (column > row) {
      diagonals_seen += 1;
    }
  } else {
    diagonals_seen = 0;
  }
  return row * n + column - diagonals_seen;
};

decode_suggestion = function(id, n) {
  var column, ref, row, value;
  value = id % (n - 1) + 1;
  ref = triangular_coordinates((id - value + 1) / (n - 1) + 1), row = ref[0], column = ref[1];
  return [row, column, value];
};

generate_suggestions = function(n) {
  var c, column, i, j, len, ref, ref1, row, suggestions, value;
  suggestions = {};
  ref = _.range(Math.pow(n - 1, 2) * n / 2);
  for (j = 0, len = ref.length; j < len; j++) {
    i = ref[j];
    ref1 = decode_suggestion(i, n), row = ref1[0], column = ref1[1], value = ref1[2];
    c = [];
    c.push(linear_coordinates(row, column, n));
    c.push(linear_coordinates(column, row, n));
    c.push(n * (n - 1) + n * row + (value - 1));
    c.push(n * (n - 1) + n * column + (value - 1));
    suggestions[i] = c;
  }
  return suggestions;
};

suggestions_to_matrix = function(suggestions, n) {
  var column, i, j, len, m, ref, row, s, value;
  m = (function() {
    var j, ref, results;
    results = [];
    for (i = j = 1, ref = n; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
      results.push(new Array(n));
    }
    return results;
  })();
  for (j = 0, len = suggestions.length; j < len; j++) {
    s = suggestions[j];
    ref = decode_suggestion(s, n), row = ref[0], column = ref[1], value = ref[2];
    m[row][column] = value;
    m[column][row] = value;
  }
  return m;
};

symmetrical_latin_square = function*(n) {
  var constraints, suggestions;
  suggestions = generate_suggestions(n);
  constraints = invert_constraints(suggestions);
  for (s of solve(constraints)) {;
  (yield suggestions_to_matrix(s, n));
  };
  return null;
};
